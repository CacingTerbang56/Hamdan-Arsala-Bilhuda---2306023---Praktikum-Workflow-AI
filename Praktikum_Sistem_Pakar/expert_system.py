# -*- coding: utf-8 -*-
"""Expert System.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1IEE0cxsHDPwely0YRN5Q-hJdeH83fLdz
"""

!pip install experta

!pip install --upgrade frozendict

from experta import *

class Diagnosis(KnowledgeEngine):
    @Rule(Fact(cough=True) & Fact(fever=True)& Fact(fatigue=True))
    def flu(self):
      print("diagnosis=anda flu")

    @Rule(Fact(cough=True) & Fact(fever=True)& Fact(breathing_difficulty=True))
    def pneumonia(self):
      print("diagnosis=anda pneumonia")

    @Rule(Fact(sneezing=True) & Fact(runny_nose=True)& Fact(cough=False))
    def covid(self):
      print("diagnosis=anda covid")

    @Rule(Fact(sore_throat=True) & Fact(fever=True))
    def throat_infection(self):
      print("diagnosis=anda infeksi tenggorokan")

    @Rule(Fact(cough=False) & Fact(fever=False)& Fact(fatigue=False))
    def healty(self):
      print("diagnosis=anda kanker")



def get_input():
    """Helper function to get user input as boolean (yes/no)."""
    def ask_question(question):
      return input(question + "(yes/no):").strip().lower()=="yes"

    return {
      "cough": ask_question("Apakah anda batuk?"),
      "fever": ask_question("Apakah anda demam?"),
      "fatigue": ask_question("Apakah anda lelah?"),
      "breathing_difficulty": ask_question("Apakah anda kesulitan bernafas?"),
      "sneezing": ask_question("Apakah anda bersin?"),
      "runny_nose": ask_question("Apakah anda pilek?"),
      "sore_throat": ask_question("Apakah anda sakit tenggorokan?")
    }


if __name__ == "__main__":
  symptoms = get_input()
  engine = Diagnosis()
  engine.reset()

  for symptom,present in symptoms.items():
    engine.declare(Fact(**{symptom:present}))

  engine.run()

from experta import *

class Diagnosis(KnowledgeEngine):
    @Rule(Fact(demam=True) & Fact(batuk=True))
    def flu(self):
      print("diagnosis=anda flu")

    @Rule(Fact(sakit_tenggorokan=True) & Fact(demam=True))
    def throat_infection(self):
      print("diagnosis=anda radang tenggorokan")

    @Rule(Fact(nyeri_otot=True) & Fact(nyeri_perut=True))
    def hernia(self):
      print("diagnosis=anda hernia")

engine = Diagnosis()
engine.reset()
engine.declare(Fact(demam=True))
engine.declare(Fact(batuk=True))

engine.run()

def forward_chaining(facts, rules):
    inferred_facts = set(facts) # inferred_facts is initialized here
    changed = True
    while changed:
      changed = False
      for rule in rules:
        # Use inferred_facts instead of inferred
        if rule["if"].issubset(inferred_facts) and rule["then"] not in inferred_facts:
          inferred_facts.add(rule["then"])
          changed = True
    return inferred_facts # Return inferred_facts

facts = {"has_feathers", "has_beak", "carnivore"}
rules = [
      {"if": {"has_feathers", "has_beak"}, "then": "is_bird"},
      {"if": {"lays_egg", "is_bird"}, "then": "is_chicken"},
      {"if": {"cannot_fly", "is_bird"}, "then": "is_penguijn"},
      {"if": {"carnivore", "is_bird"}, "then": "is_eagle"},
  ]

result = forward_chaining(facts, rules)
print("Inferred facts:", result)



def backward_chaining(goal, facts, rules):
  if goal in facts:
    return True
  for rule in rules:
    if rule["then"]==goal:
      # Check if all conditions in the rule are provable using recursion,
      # but make sure to pass the condition (cond) as the new goal
      # in the recursive calls and check against the facts.
      if all(backward_chaining(cond, facts, rules) for cond in rule["if"]):
        return True
  return False

facts = {"like_computers", "solve_problems", "likes_to_design"}
rules = [
      {"if": {"like_computers", "solve_problems"}, "then": "engineer"},
      {"if": {"engineer", "likes_programming"}, "then": "software_engineer"},
      {"if": {"engineer", "likes_to_design"}, "then": "UI/UX_designer"},
  ]
goal = "UI/UX_designer"
result = backward_chaining(goal, facts, rules)
print(f"is'{goal}'provable? ->",result)

def forward_chaining(facts, rules):
    inferred_facts = set(facts) # inferred_facts is initialized here
    changed = True
    while changed:
      changed = False
      for rule in rules:
        # Use inferred_facts instead of inferred
        if rule["if"].issubset(inferred_facts) and rule["then"] not in inferred_facts:
          inferred_facts.add(rule["then"])
          changed = True
    return inferred_facts # Return inferred_facts

facts = {"has_wheels", "has_engine", "has_four_wheels"}
rules = [
      {"if": {"has_wheels", "has_engine"}, "then": "is_vehicle"},
      {"if": {"is_vehicle", "has_two_wheels"}, "then": "is_motor"},
      {"if": {"is_vehicle", "has_four_wheels"}, "then": "is_mobil"},
  ]

result = forward_chaining(facts, rules)
print("Inferred facts:", result)

def backward_chaining(goal, facts, rules):
  if goal in facts:
    return True
  for rule in rules:
    if rule["then"]==goal:
      # Check if all conditions in the rule are provable using recursion,
      # but make sure to pass the condition (cond) as the new goal
      # in the recursive calls and check against the facts.
      if all(backward_chaining(cond, facts, rules) for cond in rule["if"]):
        return True
  return False

facts = {"has_feather", "has_small_wings"}
rules = [
      {"if": {"has_feather"}, "then": "bird"},
      {"if": {"has_small_wings"}, "then": "cant_fly"},
      {"if": {"bird", "cant_fly"}, "then": "pinguin"},
  ]
goal = "pinguin"
result = backward_chaining(goal, facts, rules)
print(f"is'{goal}'provable? ->",result)